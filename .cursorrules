# Cursor AI Rules for LoveIQ Web

> This file configures Cursor AI to follow the same security and coding standards as other AI assistants.

## Primary Documentation

**READ THESE FIRST:**
- `CLAUDE.md` - Main codebase instructions and architecture
- `SECURITY.md` - Security policy and procedures
- `SECURITY_SCANNING.md` - Security scanning details
- `.github/SECURITY_CHECKLIST.md` - Developer security checklist

## Quick Reference

### Project Type
- Next.js 16 App Router marketing site
- TypeScript + React + Tailwind CSS
- No user authentication (pre-launch marketing)
- API routes for waitlist/contact forms

### Critical Security Rules

**NEVER do this:**
- ❌ Commit secrets/API keys in code
- ❌ Use `console.log()` (use console.info/warn/error)
- ❌ Use `eval()` or `new Function()`
- ❌ Use `dangerouslySetInnerHTML` without sanitization
- ❌ Use `Math.random()` for security-sensitive operations
- ❌ Access `process.env.*` in client components (only `NEXT_PUBLIC_*`)
- ❌ Skip CSRF verification in API routes
- ❌ Skip rate limiting in API routes
- ❌ Skip input validation (always use Zod)

**ALWAYS do this:**
- ✅ Use `crypto.getRandomValues()` for security
- ✅ Verify CSRF tokens in POST/PUT/DELETE/PATCH routes
- ✅ Apply rate limiting to all POST routes
- ✅ Validate inputs with Zod schemas
- ✅ Use generic error messages (no information disclosure)
- ✅ Sanitize user input before rendering
- ✅ Run `npm run lint` before committing
- ✅ Run `npm run build` to verify changes

### API Route Template

Every API route MUST follow this pattern:

```typescript
import { NextResponse } from "next/server";
import { z } from "zod";
import { verifyCsrfToken } from "@/lib/csrf";
import { checkRateLimit, getClientIp } from "@/lib/ratelimit";

const schema = z.object({
  email: z.string().email().max(320),
});

export async function POST(request: Request) {
  // 1. CSRF verification
  if (!(await verifyCsrfToken(request))) {
    return NextResponse.json({ error: "Invalid request." }, { status: 403 });
  }

  // 2. Rate limiting
  const ip = getClientIp(request);
  const rateLimit = await checkRateLimit(ip, {
    bucket: "route-name",
    limit: 5,
    windowMs: 60_000,
  });
  if (!rateLimit.allowed) {
    return NextResponse.json({ error: "Please try again later." }, { status: 429 });
  }

  // 3. Validation
  const parsed = schema.safeParse(await request.json().catch(() => ({})));
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }

  // 4. Business logic
  try {
    // ... do work
    return NextResponse.json({ success: true });
  } catch (err) {
    console.error("Error:", err);
    return NextResponse.json({ error: "Unable to process request." }, { status: 500 });
  }
}
```

### File Organization

**Existing patterns to follow:**
- Landing sections: `components/landing/S##Name.tsx`
- API routes: `app/api/[name]/route.ts`
- Utilities: `lib/[name].ts`
- Types: Inline (no separate types directory)

**Before creating new files:**
1. Check if similar functionality exists
2. Follow existing naming conventions
3. Prefer editing existing files over creating new ones

### Environment Variables

| Type | Usage | Example |
|------|-------|---------|
| Server-only | No prefix | `SUPABASE_SERVICE_ROLE_KEY` |
| Client-safe | `NEXT_PUBLIC_` | `NEXT_PUBLIC_SITE_URL` |

**Rule:** Only `NEXT_PUBLIC_*` variables are available in client components.

### Code Style

- Use TypeScript strict mode
- Functional components with TypeScript FC type
- Tailwind CSS for styling (use design tokens in `globals.css`)
- ESLint rules must pass
- No emoji in code unless explicitly requested

### Testing Changes

Before completing work:
1. Run `npm run lint` - must pass
2. Run `npm run build` - must succeed
3. Test affected functionality manually
4. Review security checklist

### Security Headers

All security headers are set in `proxy.ts` (middleware):
- Content-Security-Policy (nonce-based)
- X-Frame-Options: DENY
- X-Content-Type-Options: nosniff
- Strict-Transport-Security
- Referrer-Policy

**If adding third-party scripts:** Update CSP in `proxy.ts`

### Dependencies

- Check `package.json` before adding new dependencies
- Avoid dependencies with known vulnerabilities
- Use `npm audit` to check security
- Compatible licenses only (no GPL-3.0, AGPL-3.0)

### Error Handling

**Generic errors only:**
```typescript
// ✅ GOOD
return NextResponse.json({ error: "Invalid input" }, { status: 400 });

// ❌ BAD (information disclosure)
return NextResponse.json({ error: "Email admin@company.com not found" }, { status: 400 });
```

### When Uncertain

1. Check existing similar code in the repo
2. Review `.planning/codebase/` documentation
3. Follow patterns in `CLAUDE.md`
4. Ask user rather than guessing on security changes

### Commit Messages

Follow conventional commits:
- `feat:` - New feature
- `fix:` - Bug fix
- `chore:` - Maintenance
- `docs:` - Documentation
- `security:` - Security fix

Example:
```
feat: add new landing section for testimonials

- Create S15Testimonials.tsx component
- Add to LandingPage composition
- Follow existing section patterns
```

### Red Flags to Avoid

Reject or warn about:
- Hardcoded secrets (even in comments/tests)
- Missing security controls in API routes
- Unsafe patterns (eval, dangerouslySetInnerHTML)
- Direct database access from client
- Missing error handling
- Information disclosure in errors
- Weak cryptography

### Resources

- **Architecture:** `.planning/codebase/ARCHITECTURE.md`
- **Conventions:** `.planning/codebase/CONVENTIONS.md`
- **Security:** `SECURITY.md`, `SECURITY_SCANNING.md`
- **Quick Reference:** `.github/SECURITY_QUICK_REFERENCE.md`

---

**Remember:** Security is everyone's responsibility. When in doubt, follow the checklist and ask!
